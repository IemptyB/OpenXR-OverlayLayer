destroying main session
    poison all overlay IPC using ConnectionToOverlay
    SetEvent(gNegotiationChannels.mainNegotiateThreadStop);
    WaitForSingleObject(gNegotiationChannels.mainThread, INFINITE);
    gMainSessionInstance = XR_NULL_HANDLE;
    ReleaseMutex(gNegotiationChannels.mainMutexHandle);

destroying instance that was used to create main session
    if(instance == gMainSessionInstance) {
        call same functions as destroy main session
    }



ActionSet: name, localized name, priority
    xrCreateActionSet
        Main - create
        Overlay - make local container for actions
    xrDestroyActionSet
Action: type, name, localized name, subaction paths
    xrCreateAction
        Main - create
        Overlay - save local state
    xrDestroyAction
    local action saved state
xrSuggestInteractionProfileBindings
    Main
        execute, save bindings for comparison
    Overlay
        save bindings locally
xrAttachSessionActionSets
    Overlay
        must pretend to be runtime...
        return XR_ERROR_ACTIONSETS_ALREADY_ATTACHED if already saved
        save sets for the session
xrGetCurrentInteractionProfile
    Overlay
        IPC to main, get profile
        Have to pretend to be Runtime a little bit
            XR_ERROR_ACTIONSET_NOT_ATTACHED
        return profile to overlay if it matches any provided to SuggestInteractionProfile on overlay
    MainAsOverlay
        return some kind of error if Main has not attached yet and returns XR_ERROR_ACTIONSET_NOT_ATTACHED
    Main
        track whether action is attached to this session
xrSyncActions
    Overlay
        IPC Action names and suggestedprofile to MainAsOverlay
    MainAsOverlay
        call xrSyncActions on bound actionsets?
        xrEnumerateBoundSourcesForAction for all actions on Overlay side
        get all bound actions from Overlay and pass back
    Main
xrEnumerateBoundSourcesForAction
xrGetInputSourceLocalizedName
GetActionState
    xrGetActionStateBoolean
    xrGetActionStateFloat
    xrGetActionStateVector2f
    xrGetActionStatePose
    Overlay
        return values previously stored by xrSyncActions
    MainAsOverlay
        nothing?
    Main
        call normally
HapticFeedback
    xrStopHapticFeedback
    xrApplyHapticFeedback
        Overlay
            has to map local actions to remote actions
        MainAsOverlay
            call on Action matching the paths provided
        Main
            normal
xrCreateActionSpace
    meed to map overlay action to remote action somehow

SuggestInteractionProfileBindings provides a tuple {interaction_profile path, binding path, action}
    EnumerateBoundSourcesForAction provides 0 or more source binding paths for an action
        source binding paths can be changed into strings
        each can be compared against other interaction profile binding path strings



need to emit for XrPath, XrAction, XrActionSet, XrSystemId
    Overlay side function to pack up a request to main to create one
        XrPath -> string used on creation in Overlay
        XrActionSet -> XrCreateActionSetInfo used on creation in Overlay
        XrAction -> XrCreateActionInfo used on creation in Overlay
    MainAsOverlay function to create those bits
    need to carefully manage errors

possibly_IPC_commands = { Session and all child handle commands }
in Python, if command_name in IPC_commands,
    emit in CommandName:
        check local handle to see if remote proxy
        if(remote proxy)
            CommandNameOverlay(params)
        else
            CommandNameMain(params)
    emit CommandNameOverlay(params)
        for each handle in parameters in XrSpace, XrSwapchain
            substitute proxy handle
        for each handle in parameters in XrAction, XrActionSet
            if there is no proxy handle, create the proxy handle through main
        for each atom in parameters in XrPath, XrSystemId
            if there is no proxy atom, create the proxy atom through main
        substitute proxy Handles and Paths in parameters to send
        pack up commands, add pointers to list, make pointers relative, send over IPC
        unpack results
        deproxy Handles and Paths in returned parameters
        if created XrSpace or XrSwapchain,
            create unique id, return that
    emit CommandNameMain(params)
        call downchain normally with possible caching of create params
    emit CommandNameMainAsOverlay(params)
        take mutex
        call downchain
        return result
    emit body of thread loop looking in shared mem for command name ID
        make pointers absolute
        call CommandNameMainAsOverlay
        make pointers relative
        return result


void* IPCGetSharedMemory()
{
    return shared_mem;
}

// Call from Overlay to connect to the Main or timeout
 IPCConnectResult IPCXrConnectToMain()
{
    // store our process ID for handshake
    ((DWORD*)shared_mem)[REMOTE_PROCESS_ID_WORD] = GetCurrentProcessId();

    // Wait on the Main to set up connection
    DWORD result = WaitForSingleObject(gOverlayWaitingOnConnectionSema, CONNECT_WAIT_MILLIS);

    if(result == WAIT_TIMEOUT) {
        return IPC_CONNECT_TIMEOUT;
    }

    if(result == WAIT_OBJECT_0 + 0) {
        // Get the Main's process ID
        DWORD hostProcessId = ((DWORD*)shared_mem)[HOST_PROCESS_ID_WORD];
        gMainProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, TRUE, hostProcessId);

        // Release the Main to get our process Id and continue
        ReleaseSemaphore(gMainWaitingOnConnectionSema, 1, nullptr);

        // Then wait one more time until we know the Main has our process
        // ID so we don't overwrite it with something else
        DWORD result = WaitForSingleObject(gOverlayWaitingOnConnectionSema, CONNECT_HANDSHAKE_WAIT_MILLIS);

        if(result == WAIT_TIMEOUT) {
            return IPC_CONNECT_TIMEOUT;
        }

        return IPC_CONNECT_SUCCESS;
    }

    return IPC_CONNECT_ERROR;
}

// Call from Main to set up connection from the Overlay
void IPCSetupForOverlayConnection()
{
    DWORD result;

    // clear request and response semaphores
    result = WaitForSingleObject(gMainResponseSema, 0);
    if(result == WAIT_OBJECT_0) {
        OutputDebugStringA("**OVERLAY** Ah, indeed there was a MainResponse sema posted\n");
    } else {
        OutputDebugStringA("**OVERLAY** No MainResponse sema posted\n");
    }
    result = WaitForSingleObject(gOverlayRequestSema, 0);
    if(result == WAIT_OBJECT_0) {
        OutputDebugStringA("**OVERLAY** Ah, indeed there was a OverlayRequest sema posted\n");
    } else {
        OutputDebugStringA("**OVERLAY** No OverlayRequest sema posted\n");
    }

    // store our process ID for handshake
    ((DWORD*)shared_mem)[HOST_PROCESS_ID_WORD] = GetCurrentProcessId();

    // Signal the remote that the host is waiting on a connection
    ReleaseSemaphore(gOverlayWaitingOnConnectionSema, 1, nullptr);
}

// Call from Main to get Overlay Connection or timeout
IPCConnectResult IPCWaitForOverlayConnection()
{
    // Wait on the remote connection
    DWORD result;
    result = WaitForSingleObject(gMainWaitingOnConnectionSema, CONNECT_WAIT_MILLIS);

    if(result == WAIT_TIMEOUT) {
        return IPC_CONNECT_TIMEOUT;
    }

    if(result == WAIT_OBJECT_0) {

        // Get the Overlay's process ID
        DWORD remoteProcessId = ((DWORD*)shared_mem)[REMOTE_PROCESS_ID_WORD];
        gOverlayProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, TRUE, remoteProcessId);

        // Finally, let the Overlay know we have its ID
        ReleaseSemaphore(gOverlayWaitingOnConnectionSema, 1, nullptr);

        return IPC_CONNECT_SUCCESS;
    }

    return IPC_CONNECT_ERROR;
}

// Call from Overlay when request in shmem is complete
void IPCFinishOverlayRequest()
{
    ReleaseSemaphore(gOverlayRequestSema, 1, nullptr);
}

// Call from Main to get complete request in shmem
IPCWaitResult IPCWaitForOverlayRequestOrTermination()
{
    HANDLE handles[2];

    handles[0] = gOverlayRequestSema;
    handles[1] = gOverlayProcessHandle;

    DWORD result;

    do {
        result = WaitForMultipleObjects(2, handles, FALSE, REMOTE_REQUEST_WAIT_MILLIS);
    } while(result == WAIT_TIMEOUT);

    if(result == WAIT_OBJECT_0 + 0) {
        return IPC_REMOTE_REQUEST_READY;
    }

    if(result == WAIT_OBJECT_0 + 1) {
        return IPC_REMOTE_PROCESS_TERMINATED;
    }

    return IPC_WAIT_ERROR;
}

// Call from Main when response in shmem is complete
void IPCFinishMainResponse()
{
    ReleaseSemaphore(gMainResponseSema, 1, nullptr);
}

// Call from Overlay to get complete request in shmem
IPCWaitResult IPCWaitForMainResponse()
{
    DWORD result;

    HANDLE handles[2];

    handles[0] = gMainResponseSema;
    handles[1] = gMainProcessHandle;

    do {
        result = WaitForMultipleObjects(2, handles, FALSE, HOST_RESPONSE_WAIT_MILLIS);
    } while(result == WAIT_TIMEOUT);

    if(result == WAIT_OBJECT_0 + 0) {
        return IPC_HOST_RESPONSE_READY;
    }

    if(result == WAIT_OBJECT_0 + 1) {
        return IPC_HOST_PROCESS_TERMINATED;
    }

    return IPC_WAIT_ERROR;
}

// Set up shared memory using a named file-mapping object. 
bool MapSharedMemory(UINT32 req_memsize)
{ 
    mutex_handle = CreateMutex(NULL, TRUE, kSharedMutexName);
    if (NULL == mutex_handle) return false;
    bool first = (GetLastError() != ERROR_ALREADY_EXISTS); 

    shared_mem_handle = CreateFileMapping( 
        INVALID_HANDLE_VALUE,   // use sys paging file instead of an existing file
        NULL,                   // default security attributes
        PAGE_READWRITE,         // read/write access
        0,                      // size: high 32-bits
        req_memsize,            // size: low 32-bits
        kSharedMemName);        // name of map object

    if (NULL == shared_mem_handle)
    {
        OutputDebugStringA("**OVERLAY** failed to CreateFileMapping\n");
        if (first) ReleaseMutex(mutex_handle); 
        CloseHandle(mutex_handle);
        return false; 
    }

    // Get a pointer to the file-mapped shared memory, read/write
    shared_mem = MapViewOfFile(shared_mem_handle, FILE_MAP_WRITE, 0, 0, 0);
    if (NULL == shared_mem) 
    {
        OutputDebugStringA("**OVERLAY** failed to MapViewOfFile\n");
        if (first) ReleaseMutex(mutex_handle); 
        CloseHandle(mutex_handle);
        return false; 
    }

    MEMORY_BASIC_INFORMATION mbi = { 0 };
    VirtualQueryEx(GetCurrentProcess(), shared_mem, &mbi, sizeof(mbi));
    mem_size = mbi.RegionSize;

    // First will initialize memory
    if (first)
    {
        memset(shared_mem, '\0', mem_size); 
        ReleaseMutex(mutex_handle);
    }
    
    return true;
}

// Unmap the shared memory and release handle
//
bool UnmapSharedMemory()
{
    // Close handle to mutex
    CloseHandle(mutex_handle);

    // Unmap shared memory from the process's address space
    bool err = UnmapViewOfFile(shared_mem); 
 
    // Close the process's handle to the file-mapping object
    if (!err) err = CloseHandle(shared_mem_handle);

    return err;
} 

