9/2
I was able to make more than 9800 XrPaths on Oculus' RT
I was able to make 9998 XrActions on Oculus' RT

8/17
Items in IPCSerialize
    auto dst = new(ipcbuf) IPCXrCommandName;
    atomic
        xr handle -> direct copy (asume other function does handle substitution)
            "type" : "POD"
            "pod_type" : handle_type
        xr atom -> direct copy
            "type" : "POD"
            "pod_type" : atom_type
        capacity INPUT / uint32_t -> direct copy
            "type" : "POD"
            "pod_type" : "uint32_t"
    pointer to thingie output
        MUST addOffsetToPointer for all serialized pointers
        capacity OUTPUT / uint32_t -> IPCSerializeNoCopy template on one item
            "type" : "pointer_to_pod"
            "pod_type" : "uint32_t"
        pointer to block of atomics / uint32_t -> IPCSerializeNoCopy template on array 
            "type" : "fixed_array"
            "base_type" : ...
            "size" : input variable
            e.g. swapchain formats, viewConfigurationTypes
        pointer to INPUT XR struct chain -> IPCSerialize to generated Copy, COPY_EVERYTHING
            "is_const" : True
            "type" : "xrstruct_pointer"
            "struct_type" : ...
            these are "const" in parameters
            e.g. GetInstanceProperties
        pointer to OUTPUT XR struct chain -> IPCSerialize to generated Copy, COPY_ONLY_TYPE_NEXT (but this is an optimization, should be safe to copy?)
            "is_const" : False
            "type" : "xrstruct_pointer"
            "struct_type" : ...
            these are NOT "const" in parameters
            e.g. GetInstanceProperties
        pointer to OUTPUT block of XR structs
            "type" : "pointer_to_xr_struct_array"
            "struct_type" : member["size"], member["member_text"])
            "name" : name
            "size" : size variable or enum
            new(ipcbuf) block of structs, then for each element in array
                copy ->type
                call IPCSerialize on each element.next
            e.g. IPCXrEnumerateViewConfigurationViews


8/13
shared_ptr guarantees thread-safe control - deletion, copy, reset, etc.
    https://www.modernescpp.com/index.php/atomic-smart-pointers#:~:text=yes%20and%20no.-,Why%3F,will%20be%20deleted%20exactly%20once.
    But OBJECT is still not thread safe.
    all members could be private and all methods take the lock
        init-only const accessors for private members (need to put in ctor) - no locking
        otherwise return-by-value and set functions would lock in order to be atomic / exclusive

8/12
Make as many objects simple copies as possible (e.g. RPCConnections is just HANDLEs and DWORDs and void*s)
Identify any objects that may be accessed by multiple threads and why
    unordered_maps mapping handles to tracking state must be locked
        will be appended from negotiation thread
        may have elements removed by overlay service thread
    map of overlay thread ID to overlay state
    list of overlay-owned objects in main process does *not* need to be locked?
        they will only get destroyed in the overlay service thread?  What about 
Why not just lock every API layer call?
    Why?  Only Destroy has to be externally synchronized.  That means we won't be inside an XR command in an app's explicit threads when the handle is Destroyed.
        But we could be in the overlay service thread accessing, say XrSession, when it is Destroyed. 


possibly_IPC_commands = { Session and all child handle commands }
in Python, if command_name in IPC_commands,
    emit in CommandName:
        check local handle to see if remote proxy
        if(remote proxy)
            CommandNameOverlay(params)
        else
            CommandNameMain(params)
    emit CommandNameOverlay(params)
        for each handle in parameters in XrSpace, XrSwapchain
            substitute proxy handle
        for each handle in parameters in XrAction, XrActionSet
            if there is no proxy handle, create the proxy handle through main
        for each atom in parameters in XrPath, XrSystemId
            if there is no proxy atom, create the proxy atom through main
        substitute proxy Handles and Paths in parameters to send
        pack up commands, add pointers to list, make pointers relative, send over IPC
        unpack results
        deproxy Handles and Paths in returned parameters
        if created XrSpace or XrSwapchain,
            create unique id, return that
    emit CommandNameMain(params)
        call downchain normally with possible caching of create params
    emit CommandNameMainAsOverlay(params)
        take mutex
        call downchain
        return result
    emit body of thread loop looking in shared mem for command name ID
        make pointers absolute
        call CommandNameMainAsOverlay
        make pointers relative
        return result

Any RPC should check for Main Instance lost, return INSTANCE_LOST and Overlay convert to INITIALIZATION_FAILED

destroying main session
    poison all overlay IPC using ConnectionToOverlay
    SetEvent(gNegotiationChannels.mainNegotiateThreadStop);
    WaitForSingleObject(gNegotiationChannels.mainThread, INFINITE);
    gMainSessionInstance = XR_NULL_HANDLE;
    ReleaseMutex(gNegotiationChannels.mainMutexHandle);

destroying instance that was used to create main session
    if(instance == gMainSessionInstance) {
        call same functions as destroy main session
    }



/interaction_profiles/microsoft/xbox_controller/user/gamepad/input/thumbstick_left/click
    /interaction_profiles/microsoft/xbox_controller
    /user/gamepad
    .../input/thumbstick_left/click

VirtualActionSet {
    createInfo
}

VirtualAction {
    createInfo
    XrResult getBoolean(XrActionStateBoolean *state)
    {
        if(createInfo->type != XR_ACTION_TYPE_BOOLEAN_INPUT) {
            return XR_ERROR_ACTION_TYPE_MISMATCH; 
        }
        *state = booleanState;
        return XR_SUCCESS;
    }
    // etc
    union {
        XrActionStateBoolean booleanState;
        // etc;
    };
    Ctor()
    {
        switch(createInfo->type) {
            case XR_ACTION_TYPE_BOOLEAN_INPUT: {
                booleanState.type = XR_TYPE_ACTION_STATE_BOOLEAN
                booleanState.next = nullptr;
                booleanState.currentState = XR_FALSE;
                booleanState.changedSinceLastSync = XR_FALSE;
                booleanState.lastChangeTime = 0;
                booleanState.isActive = XR_FALSE;
                break;
            }
                // etc
        }
    }
}

XXX NO REAL ACTION OR ACTIONSET PASSED BACK TO MAIN OR TO OVERLAY

Real ActionSet and Placeholder Actions created at Attach time

OverlaysLayerXrActionSetHandleInfo, add:
    std::vector<XrAction> actions;          // main side only
    std::set<OverlaysLayerVirtualActionHandleInfo::Ptr> localActions;        // overlay side only
    bool mutable = true; // false after attach

OverlaysLayerXrActionHandleInfo, add:
    OverlaysLayerXrActionSetHandleInfo::Ptr parentActionHandle;


So we know that if the overlay suggested for "/interaction_profiles/khr/simple_controller/" binding an action to "/user/hand/left/input/squeeze/value", we can query the action we created and bound for those.

hello_xr output:
    profile null_path
    bound "grab" to 0 sources...
    bound "pose" to 0 sources...
    bound "quit" to 0 sources...
    bound "vibrate" to 0 sources...
    [15:29:53.457][Info   ] XrEventDataSessionStateChanged: state XR_SESSION_STATE_SYNCHRONIZED->XR_SESSION_STATE_VISIBLE session=72165140019019777 time=1060087400739200
    [15:29:53.458][Info   ] XrEventDataSessionStateChanged: state XR_SESSION_STATE_VISIBLE->XR_SESSION_STATE_FOCUSED session=72165140019019777 time=1060087400774200
    profile oculus/touch_controller
    bound "grab" to 2 sources...
        "/user/hand/left/input/squeeze/value"("Left Hand Oculus Touch Squeeze")
        "/user/hand/right/input/squeeze/value"("Right Hand Oculus Touch Squeeze")
    bound "pose" to 2 sources...
        "/user/hand/left/input/grip/pose"("Left Hand Oculus Touch Grip Pose")
        "/user/hand/right/input/grip/pose"("Right Hand Oculus Touch Grip Pose")
    bound "quit" to 1 sources...
        "/user/hand/left/input/menu/click"("Left Hand Oculus Touch Menu Button")
    bound "vibrate" to 2 sources...
        "/user/hand/left/output/haptic"("Left Hand Oculus Touch Vibration")
        "/user/hand/right/output/haptic"("Right Hand Oculus Touch Vibration")

A solution must handle:
    multiple suggested bindings
    suggested profile by overlay app does not overlap profiles of main app
    priority of actionsets
    Actions are only valid after SyncActions 
    Action state is fixed between SyncActions
    ActionSet/Action is immutable after Attach
    ActionState may be an aggregation of multiple input sources, e.g. XrBool32 is OR of all valid sources
    behavior of main must not change appreciably

Applications "may" suggest interaction profile bindings
    SuggestInteractionProfileBindings provides a tuple {interaction_profile path, binding path, action}
        EnumerateBoundSourcesForAction provides 0 or more source binding paths for an action
            source binding paths can be changed into strings
            each can be compared against other interaction profile binding path strings
    if bindings aren't suggested, input can't be routed because runtime has no idea what actions mean what
    So, for a given action, IF AN INTERACTION PROFILE BINDING HAS BEEN SUGGESTED, one may reverse-lookup 0 or more interaction profile binding paths for the action.
        e.g. in hello_xr, grabAction for interaction profiles is the following bindings:
            "/interaction_profiles/khr/simple_controller"
                "/user/hand/left/input/select/click"
                "/user/hand/right/input/select/click"
            "/interaction_profiles/oculus/touch_controller"
                "/user/hand/left/input/squeeze/value"
                "/user/hand/right/input/squeeze/value"
            "/interaction_profiles/htc/vive_controller"
                "/user/hand/left/input/squeeze/click"
                "/user/hand/right/input/squeeze/click"
            "/interaction_profiles/microsoft/motion_controller" (bindings same as htc/vive_controller)
                "/user/hand/left/input/squeeze/click"
                "/user/hand/right/input/squeeze/click"
        The list of Paths for a given action can be refined further by using the current interaction profile name
            e.g. if one knows the interaction profile is oculus/touch_controller, then one can know that grabAction is {left,right}/input/squeeze/value
            if one does not know the interaction profile, then what?
                Just check all of them?
        further a subactionpath might disambiguate fully mapping an action to a binding
        if overlay suggests "select/click" for XrAction bar and main suggests "select/click" for XrAction foo, xrGetActionStateBoolean on bar could return the same as for foo.
    However, an app might suggest only khr/simple_controller and might not suggest any others
        what if overlay suggests "khr/simple_controller" "select/click" for XrAction bar, and main suggests "oculus/touch_controller" "squeeze/value" for XrAction foo.
            Should OverlaysLayer be responsible for converting input profiles?
                xrGetCurrentInteractionProfile would need to translate from oculus/touch_controller to khr/simplecontroller
                xrGetActionStateBoolean would need to know {"oculus/touch_controller","squeeze/value"} can be reasonably approximated by {"khr/simple_controller","select/click"}
                Overlay Layer would need a mapping with entries from {main profile, main binding} to {overlay profile, overlay binding}
                if main suggests bindings in a profile that Overlay Layer doesn't know, probably have to punt for now.
                Maybe punt in general if main's selected interaction profile is not suggested at all by overlay.
    overlay XrActions may not have the same types as main XrActions for the same bindings.
        May be able to do conversions one direction but not the other..
        punt here too if they don't match?
    An overlay app may suggest bindings for a profile that don't 100% overlap with 100% of main app's bindings
        also punt, I guess.  Some overlay app Actions won't then receive input.
    Finally, an XrAction may be bound to multiple input paths.  See 11.5.1 - "Resolving a single action bound to multiple inputs or outputs" for how that's resolved
    XrAction -> look up in suggested interaction bindings, refine by current interaction profile, results in >= 0 profile paths
        need to catch profile changed event 

to get to something working for feasibility
    CreateActionSet
    CreateAction
    CreateActionSpace
    SyncActions
    AttachSessionActionSets
    GetActionState*

xrPollEvent
    Main
        if profile changed event, save the current profile
    Overlay
        translate profile changed event if possible

CreateActionSet
    main: downchain->CreateActionSet
    overlay: create virtual actionset
CreateAction
    main: downchain->CreateAction
    overlay: create virtual action
SuggestInteractionProfileBindings
    main: save off bindings
    overlay: save off bindgs, use to map from Action to input source
        if any action is attached localAction, XR_ERROR_ACTIONSETS_ALREADY_ATTACHED
        If interaction profile path does not follow structure defined
          in Interaction Profiles or suggested bindings contain paths
          that do not follow format defined in Device input subpaths,
          XR_ERROR_PATH_UNSUPPORTED
AttachSessionActionSets
    main: call downchain->SuggestInteractionProfileBindings
    overlay: virtual, so register and that's it
        must pretend to be runtime: return XR_ERROR_ACTIONSETS_ALREADY_ATTACHED if OVERLAY and already attached
        note virtual actionsets and virtual actions in Session
        mark virtual actionsets and virtual actions bound to OVERLAY, mutable = false
CreateActionSpace
    NB the target Action must be a POSE action
    main: downchain->CreateActionSpace
    overlay: store request, actually create at Attach when I'll know what the bindings are
        so LocateSpace until Attach should pretend and return inactive 
        space will be created against a particular action
            just pick the first pose listed as a suggested binding
            Or do multiple spaces need to be created and pick the first active one at LocateSpace time?
SyncActions
    main: get all state for active actionsets, store, set remaining inactive.
    overlay: RPC to get all state for active actionsets, store, set remaining inactive.
GetActionState*
    if function doesn't match action type, XR_ERROR_ACTION_TYPE_MISMATCH
    XR_ERROR_ACTIONSET_NOT_ATTACHED
    get cached value
    XXX need to store values inactive on initialization
ApplyHapticFeedback
    main: map local to actual, downchain->ApplyHapticFeedback
    overlay: map local to placeholder, RPC to Apply in main
xrEnumerateBoundSourcesForAction
    main: downchain->EnumerateBoundSourcesForAction
    overlay: ??
xrGetInputSourceLocalizedName
    main: downchain->GetInputSourceLocalizedName
    overlay: ??
xrGetCurrentInteractionProfile
    Main
        execute normally - anything else?
    Overlay
        if actionsets not attached, XR_ERROR_ACTIONSETS_NOT_ATTACHED
        IPC to main to get path
            return NULL_PATH if not yet actionsets attached
            return profile string to overlay
        if it matches any provided to SuggestInteractionProfile on overlay
            return that one
        else
            if it matches one we know how to convert to KHR
                return KHR
            else
                return NULL_PATH
    MainAsOverlay
        return result or NULL_PATH if not attached

