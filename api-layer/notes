struct NegotiationParams
{
    DWORD mainProcessId;
    DWORD overlayProcessId;
    uint32_t mainLayerBinaryVersion;
    uint32_t overlayLayerBinaryVersion;
};

struct NegotiationChannels
{
    HANDLE shmemHandle;
    HANDLE mutexHandle;
    NegotiationParams* params;
    HANDLE overlayWaitSema;
    HANDLE mainWaitSema;
    HANDLE mainThread;
    DWORD mainThreadId;
    HANDLE mainNegotiateThreadStop;
    enum {SUCCESS, DIFFERENT_BINARY_VERSION} status;
    static const char *shmemName;
    static const char *mutexName;
    static const uint32_t shmemSize;

} gNegotiationChannels;

const char *NegotiationChannels::shmemName = "LUNARG_XR_EXTX_overlay_negotiation_shmem";
const char *NegotiationChannels::overlayWaitSemaName = "LUNARG_XR_EXTX_overlay_negotiation_overlay_wait_sema";
const char *NegotiationChannels::mainWaitSemaName = "LUNARG_XR_EXTX_overlay_negotiation_main_wait_sema";
const char *NegotiationChannels::mutexName = "LUNARG_XR_EXTX_overlay_negotiation_mutex";
const uint32_t NegotiationChannels::shmemSize = sizeof(NegotiationParams);
const DWORD NegotiationChannels::mutexWaitMillis = 500;

bool gHaveMainSessionActive = false;
XrInstance gMainSessionInstance;
HANDLE gMainOverlayMutexHandle; // Held when Main and MainAsOverlay functions need to run exclusively

// Both main and overlay processes call this function, which creates/opens
// the negotiation mutex, shmem, and semaphores.
bool OpenNegotiationChannels(NegotiationChannels &ch)
{
    ch.mutexHandle = CreateMutex(NULL, TRUE, gNegotiationChannels::mutexName);
    if (ch.mutexHandle == NULL) {
        DWORD lastError = GetLastError();
        LPVOID messageBuf;
        FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr, lastError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR) &messageBuf, 0, nullptr);
        OverlaysLayerLogMessage(ch.instance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT, "xrCreateSession", 
            OverlaysLayerNoObjectInfo, fmt("FATAL: Could not initialize the negotiation mutex: CreateMutex error was %d (%s)\n", lastError, messageBuf).c_str());
        LocalFree(messageBuf);
        return false;
    }

    ch.shmemHandle = CreateFileMappingA( 
        INVALID_HANDLE_VALUE,   // use sys paging file instead of an existing file
        NULL,                   // default security attributes
        PAGE_READWRITE,         // read/write access
        0,                      // size: high 32-bits
        gNegotiationChannels::shmemSize,         // size: low 32-bits
        gNegotiationChannels::shmemName);        // name of map object

    if (ch.shmemHandle == NULL) {
        DWORD lastError = GetLastError();
        LPVOID messageBuf;
        FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr, lastError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR) &messageBuf, 0, nullptr);
        OverlaysLayerLogMessage(ch.instance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT, "xrCreateSession", 
            OverlaysLayerNoObjectInfo, fmt("FATAL: Could not initialize the negotiation shmem: CreateFileMappingA error was %08X (%s)\n", lastError, messageBuf).c_str());
        LocalFree(messageBuf);
        return false; 
    }

    // Get a pointer to the file-mapped shared memory, read/write
    ch.params = reinterpret_cast<NegotiationParams*>(MapViewOfFile(ch.shmemHandle, FILE_MAP_WRITE, 0, 0, 0));
    if (ch.shmem == NULL) {
        DWORD lastError = GetLastError();
        LPVOID messageBuf;
        FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr, lastError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR) &messageBuf, 0, nullptr);
        OverlaysLayerLogMessage(ch.instance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT, "xrCreateSession", 
            OverlaysLayerNoObjectInfo, fmt("FATAL: Could not get the negotiation shmem: MapViewOfFile error was %08X (%s)\n", lastError, MessageBuf).c_str());
        LocalFree(messageBuf);
        return false; 
    }

    ch.overlayWaitSema = CreateSemaphore(nullptr, 0, 1, ch.overlayWaitSemaName);
    if(ch.overlayWaitSema == NULL) {
        DWORD lastError = GetLastError();
        LPVOID messageBuf;
        FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr, lastError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR) &messageBuf, 0, nullptr);
        OverlaysLayerLogMessage(ch.instance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT, "xrCreateSession", 
            OverlaysLayerNoObjectInfo, fmt("FATAL: Could not create negotiation overlay wait sema: CreateSemaphore error was %08X (%s)\n", lastError, MessageBuf).c_str());
        LocalFree(messageBuf);
        return false;
    }

    ch.mainWaitSema = CreateSemaphore(nullptr, 0, 1, ch.mainWaitSemaName);
    if(ch.mainWaitSema == NULL) {
        DWORD lastError = GetLastError();
        LPVOID messageBuf;
        FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr, lastError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR) &messageBuf, 0, nullptr);
        OverlaysLayerLogMessage(ch.instance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT, "xrCreateSession", 
            OverlaysLayerNoObjectInfo, fmt("FATAL: Could not create negotiation main wait sema: CreateSemaphore error was %08X (%s)\n", lastError, MessageBuf).c_str());
        LocalFree(messageBuf);
        return false;
    }

    return true;
}

DWORD WINAPI MainRPCThreadBody(XrInstance instance);

DWORD WINAPI MainNegotiateThreadBody()
{
    DWORD result;
    HANDLE handles[2];
    handles[0] = gNegotiationChannels.mainNegotiateThreadStop;
    handles[1] = gNegotiationChannels.mainWaitSema;

    while(1) {
        // Signal that one overlay app may attempt to connect
        ReleaseSemaphore(gNegotiationChannels.overlayWaitSema, 1, nullptr);

        do {
            result = WaitForMultipleObjects(2, handles, FALSE, NegotiationChannels::negotiationWaitMillis);
        } while(result == WAIT_TIMEOUT);

        if(result == WAIT_OBJECT_0 + 0) {

            // Main process has signaled us to stop, probably Session was destroyed.
            return 0;

        } else if(result != WAIT_OBJECT_0 + 1) {

            // WAIT_FAILED
            DWORD lastError = GetLastError();
            LPVOID messageBuf;
            FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr, lastError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR) &messageBuf, 0, nullptr);
            OverlaysLayerLogMessage(gNegotiationChannels.instance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT, "no function", 
                OverlaysLayerNoObjectInfo, fmt("FATAL: Could not wait on negotiation sema sema: WaitForMultipleObjects error was %08X (%s)\n", lastError, MessageBuf).c_str());
            // XXX need way to signal main process that thread errored unexpectedly
            LocalFree(messageBuf);
            return 0;
        }

        if(gNegotiationChannels.params->status != SUCCESS) {

            OverlaysLayerLogMessage(gNegotiationChannels.instance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT, "no function", 
                OverlaysLayerNoObjectInfo, fmt("WARNING: the Overlay API Layer in the overlay app has a different version (%u) than in the main app (%u), connection rejected.\n", gNegotiationChannels.params->overlayLayerBinaryVersion, gNegotiationChannels.params->mainLayerBinaryVersion).c_str());

        } else {
            DWORD overlayProcessId = gNegotiationChannels.params->overlayProcessId;
            RPCChannels channels;

            if(!OpenRPCChannels(overlayProcessId, channels)) {
                OverlaysLayerLogMessage(gNegotiationChannels.instance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT, "no function", 
                    OverlaysLayerNoObjectInfo, fmt("WARNING: couldn't open RPC channels to overlay app, connection rejected.\n").c_str());
            } else {

                /* save off negotiation parameters because they are systemwide */

                gConnectionsToOverlayByProcessId[overlayProcessId] = {channels, receiverThread, threadId};
                DWORD threadId;
                RPCChannels *threadChannels = new RPCChannels;
                *threadChannels = channels; // thread frees
                HANDLE receiverThread = CreateThread(nullptr, 0, MainRPCThreadBody, threadChannels, 0, &threadId));
            }
        }
    }
}

bool CreateMainSessionRPCThread()
{
    DWORD waitresult = WaitForSingleObject(gNegotiationChannels.mainMutexHandle, NegotiationChannels::mutexWaitMillis);
    if (waitresult == WAIT_TIMEOUT) {
        OverlaysLayerLogMessage(gNegotiationChannels.instance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT, "xrCreateSession", 
            OverlaysLayerNoObjectInfo, fmt("FATAL: Could not take main mutex sema; is there another main app running?\n").c_str());
        return false;
    }

    gNegotiationChannels.params->mainProcessId = GetCurrentProcessId();
    gNegotiationChannels.params->mainLayerBinaryVersion = gLayerBinaryVersion;
    gNegotiationChannels.mainNegotiateThreadStop = CreateEventA(nullptr, false, false, nullptr);
    gNegotiationChannels.mainThread = CreateThread(nullptr, 0, MainNegotiateThreadBody, nullptr, 0, &gNegotiationChannels.mainThreadId));

    return true;
}

struct RPCChannels
{
    HANDLE shmemHandle;
    HANDLE mutexHandle;
    void* shmem;
    HANDLE overlayRequestSema;
    HANDLE mainResponseSema;
    static const char *shmemNameTemplate;
    static const char *overlayRequestSemaNameTemplate;
    static const char *mainResponseSemaNameTemplate;
    static const char *mutexNameTemplate;
    static const uint32_t shmemSize;
    static const DWORD mutexWaitMillis;
};

const char *RPCChannels::shmemNameTemplate = "LUNARG_XR_EXTX_overlay_rpc_shmem_%u";
const char *RPCChannels::overlayRequestSemaNameTemplate = "LUNARG_XR_EXTX_overlay_rpc_overlay_request_sema_%u";
const char *RPCChannels::mainResponseSemaNameTemplate = "LUNARG_XR_EXTX_overlay_rpc_main_response_sema_%u";
const char *RPCChannels::mutexNameTemplate = "LUNARG_XR_EXTX_overlay_rpc_mutex_%u";
const uint32_t RPCChannels::shmemSize = 1024 * 1024;
const DWORD RPCChannels::mutexWaitMillis = 500;

struct ConnectionToOverlay
{
    OverlayMainRPCChannels conn;
    HANDLE thread;
    DWORD threadId;
    ConnectionToOverlay(const OverlayMainRPCChannels* conn, HANDLE thread, DWORD threadId) :
        conn(*conn),
        thread(thread),
        threadId(threadId)
    { }
};

std::map<DWORD, ConnectionToOverlay> gConnectionsToOverlayByProcessId;

struct ConnectionToMain
{
    OverlayMainRPCChannels conn;
    ConnectionToMain(const OverlayMainRPCChannels& conn) :
        ch(ch)
    { }
};

unique_ptr<ConnectionToMain> gConnectionToMain;


bool OpenRPCChannels(DWORD overlayProcessId, RPCChannels* ch)
{
    ch->mutexHandle = CreateMutex(NULL, TRUE, fmt(RPCChannels::mutexNameTemplate, overlayProcessId).c_str(), gNegotiationChannels::mutexName);
    if (ch->mutexHandle == NULL) {
        DWORD lastError = GetLastError();
        LPVOID messageBuf;
        FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr, lastError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR) &messageBuf, 0, nullptr);
        OverlaysLayerLogMessage(instance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT, "no function", 
            OverlaysLayerNoObjectInfo, fmt("FATAL: Could not initialize the RPC mutex: CreateMutex error was %d (%s)\n", lastError, messageBuf).c_str());
        LocalFree(messageBuf);
        return false;
    }

    ch->shmemHandle = CreateFileMappingA( 
        INVALID_HANDLE_VALUE,   // use sys paging file instead of an existing file
        NULL,                   // default security attributes
        PAGE_READWRITE,         // read/write access
        0,                      // size: high 32-bits
        gNegotiationChannels::shmemSize,         // size: low 32-bits
        fmt(RPCChannels::shmemNameTemplate, overlayProcessId).c_str);        // name of map object

    if (ch->shmemHandle == NULL) {
        DWORD lastError = GetLastError();
        LPVOID messageBuf;
        FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr, lastError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR) &messageBuf, 0, nullptr);
        OverlaysLayerLogMessage(instance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT, "no function", 
            OverlaysLayerNoObjectInfo, fmt("FATAL: Could not initialize the RPC shmem: CreateFileMappingA error was %08X (%s)\n", lastError, messageBuf).c_str());
        LocalFree(messageBuf);
        return false; 
    }

    // Get a pointer to the file-mapped shared memory, read/write
    ch->shmem = MapViewOfFile(ch->shmemHandle, FILE_MAP_WRITE, 0, 0, 0);
    if (ch->shmem == NULL) {
        DWORD lastError = GetLastError();
        LPVOID messageBuf;
        FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr, lastError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR) &messageBuf, 0, nullptr);
        OverlaysLayerLogMessage(instance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT, "xrCreateSession", 
            OverlaysLayerNoObjectInfo, fmt("FATAL: Could not get the RPC shmem: MapViewOfFile error was %08X (%s)\n", lastError, MessageBuf).c_str());
        LocalFree(messageBuf);
        return false; 
    }

    ch->overlayRequestSema = CreateSemaphore(nullptr, 0, 1, fmt(gNegotiationChannels::overlayRequestSemaNameTemplate, overlayProcessId).c_str);
    if(ch->overlayRequestSema == NULL) {
        DWORD lastError = GetLastError();
        LPVOID messageBuf;
        FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr, lastError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR) &messageBuf, 0, nullptr);
        OverlaysLayerLogMessage(instance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT, "xrCreateSession", 
            OverlaysLayerNoObjectInfo, fmt("FATAL: Could not create RPC overlay request sema: CreateSemaphore error was %08X (%s)\n", lastError, MessageBuf).c_str());
        LocalFree(messageBuf);
        return false;
    }

    ch->mainResponseSema = CreateSemaphore(nullptr, 0, 1, fmt(gNegotiationChannels::mainResponseSemaNameTemplate, overlayProcessId).c_str);
    if(ch->mainResponseSema == NULL) {
        DWORD lastError = GetLastError();
        LPVOID messageBuf;
        FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr, lastError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR) &messageBuf, 0, nullptr);
        OverlaysLayerLogMessage(instance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT, "xrCreateSession", 
            OverlaysLayerNoObjectInfo, fmt("FATAL: Could not create RPC main response sema: CreateSemaphore error was %08X (%s)\n", lastError, MessageBuf).c_str());
        LocalFree(messageBuf);
        return false;
    }

    return true;
}

DWORD WINAPI MainRPCThreadBody(void *param)
{
    RPCChannels *channels = reinterpret_cast<RPCChannels*>(param);

    DebugBreak();
#if 0
    bool connectionLost = false;
    do {
        IPCWaitResult result;
        result = IPCWaitForRemoteRequestOrTermination();

        if(result == IPC_REMOTE_PROCESS_TERMINATED) {

            if(gMainSession && gMainSession->overlaySession) { // Might have LOST SESSION
                ScopedMutex scopedMutex(gOverlayCallMutex, INFINITE, "overlay layer command mutex", __FILE__, __LINE__);
                gMainSession->overlaySession->swapchainMap.clear();
                gMainSession->ClearOverlayLayers();
            }
            connectionLost = true;

        } else if(result == IPC_WAIT_ERROR) {

            if(gMainSession && gMainSession->overlaySession) { // Might have LOST SESSION
                ScopedMutex scopedMutex(gOverlayCallMutex, INFINITE, "overlay layer command mutex", __FILE__, __LINE__);
                gMainSession->overlaySession->swapchainMap.clear();
                gMainSession->ClearOverlayLayers();
            }
            connectionLost = true;
            OutputDebugStringA("**OVERLAY** IPC Wait Error\n");

        } else {

            IPCBuffer ipcbuf = IPCGetBuffer();
            IPCXrHeader *hdr = ipcbuf.getAndAdvance<IPCXrHeader>();

            hdr->makePointersAbsolute(ipcbuf.base);

            connectionLost = ProcessRemoteRequestAndReturnConnectionLost(ipcbuf, hdr);

            hdr->makePointersRelative(ipcbuf.base);

            IPCFinishHostResponse();
        }

        if(connectionLost && gMainSession && gMainSession->overlaySession) {
            gMainSession->DestroyOverlaySession();
        }

    } while(!connectionLost && !gMainInstanceContext.exitIPCLoop);
#endif
}

layer init
    gMainSessionInstance = instance;
    OpenNegotiationChannels(XrInstance instance, gNegotiationChannels)


connect-to-main from overlay session
    check to make sure not already main session
        fail with XR_SESSION_INITIALIZATION_FAILED
    waits on gNegotiationChannels.overlayWaitSema (wait A) -> graceful recovery from timeout
    if(gNegotiationChannels.params->mainProcessApiLayerBinaryVersion != gLayerBinaryVersion) {
        gNegotiationParams.status = DIFFERENT_BINARY_VERSION;
        post to gNegotiationChannels.mainWaitSema (release B)
        OverlaysLayerLogMessage(instance, XR_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT, "xrCreateSession", 
            OverlaysLayerNoObjectInfo, fmt("FATAL: the Overlay API Layer in the overlay app has a different version (%u) than in the main app (%u).\n").c_str());
        return XR_ERROR_INITIALIZATION_FAILED;
    } else {
        /* save off negotiation parameters because they are systemwide */
        gNegotiationChannels.params->overlayProcessId = GetCurrentProcessId();
        post to gNegotiationChannels.mainWaitSema (release B) 
        RPCChannels channels;
        OpenRPCChannels(my process Id, &channels) -> check errors
        gConnectionToMain = std::make_unique<ConnectionToMain>(channels);
    }

destroying main session
    poison all overlay IPC using ConnectionToOverlay
    SetEvent(gNegotiationChannels.mainNegotiateThreadStop);
    WaitForSingleObject(gNegotiationChannels.mainThread, INFINITE);
    gMainSessionInstance = XR_NULL_HANDLE
    ReleaseMutex(gNegotiationChannels.mainMutexHandle);

destroying instance that was used to create main session
    if(instance == gMainSessionInstance) {
        call same functions as destroy main session
    }



ActionSet: name, localized name, priority
    xrCreateActionSet
        Main - create
        Overlay - make local container for actions
    xrDestroyActionSet
Action: type, name, localized name, subaction paths
    xrCreateAction
        Main - create
        Overlay - save local state
    xrDestroyAction
    local action saved state
xrSuggestInteractionProfileBindings
    Main
        execute, save bindings for comparison
    Overlay
        save bindings locally
xrAttachSessionActionSets
    Overlay
        must pretend to be runtime...
        return XR_ERROR_ACTIONSETS_ALREADY_ATTACHED if already saved
        save sets for the session
xrGetCurrentInteractionProfile
    Overlay
        IPC to main, get profile
        Have to pretend to be Runtime a little bit
            XR_ERROR_ACTIONSET_NOT_ATTACHED
        return profile to overlay if it matches any provided to SuggestInteractionProfile on overlay
    MainAsOverlay
        return some kind of error if Main has not attached yet and returns XR_ERROR_ACTIONSET_NOT_ATTACHED
    Main
        track whether action is attached to this session
xrSyncActions
    Overlay
        IPC Action names and suggestedprofile to MainAsOverlay
    MainAsOverlay
        call xrSyncActions on bound actionsets?
        xrEnumerateBoundSourcesForAction for all actions on Overlay side
        get all bound actions from Overlay and pass back
    Main
xrEnumerateBoundSourcesForAction
xrGetInputSourceLocalizedName
GetActionState
    xrGetActionStateBoolean
    xrGetActionStateFloat
    xrGetActionStateVector2f
    xrGetActionStatePose
    Overlay
        return values previously stored by xrSyncActions
    MainAsOverlay
        nothing?
    Main
        call normally
HapticFeedback
    xrStopHapticFeedback
    xrApplyHapticFeedback
        Overlay
            has to map local actions to remote actions
        MainAsOverlay
            call on Action matching the paths provided
        Main
            normal
xrCreateActionSpace
    meed to map overlay action to remote action somehow

SuggestInteractionProfileBindings provides a tuple {interaction_profile path, binding path, action}
    EnumerateBoundSourcesForAction provides 0 or more source binding paths for an action
        source binding paths can be changed into strings
        each can be compared against other interaction profile binding path strings



need to emit for XrPath, XrAction, XrActionSet, XrSystemId
    Overlay side function to pack up a request to main to create one
        XrPath -> string used on creation in Overlay
        XrActionSet -> XrCreateActionSetInfo used on creation in Overlay
        XrAction -> XrCreateActionInfo used on creation in Overlay
    MainAsOverlay function to create those bits
    need to carefully manage errors

possibly_IPC_commands = { Session and all child handle commands }
in Python, if command_name in IPC_commands,
    emit in CommandName:
        check local handle to see if remote proxy
        if(remote proxy)
            CommandNameOverlay(params)
        else
            CommandNameMain(params)
    emit CommandNameOverlay(params)
        for each handle in parameters in XrSpace, XrSwapchain
            substitute proxy handle
        for each handle in parameters in XrAction, XrActionSet
            if there is no proxy handle, create the proxy handle through main
        for each atom in parameters in XrPath, XrSystemId
            if there is no proxy atom, create the proxy atom through main
        substitute proxy Handles and Paths in parameters to send
        pack up commands, add pointers to list, make pointers relative, send over IPC
        unpack results
        deproxy Handles and Paths in returned parameters
        if created XrSpace or XrSwapchain,
            create unique id, return that
    emit CommandNameMain(params)
        call downchain normally with possible caching of create params
    emit CommandNameMainAsOverlay(params)
        take mutex
        call downchain
        return result
    emit body of thread loop looking in shared mem for command name ID
        make pointers absolute
        call CommandNameMainAsOverlay
        make pointers relative
        return result


void* IPCGetSharedMemory()
{
    return shared_mem;
}

// Call from Overlay to connect to the Main or timeout
 IPCConnectResult IPCXrConnectToMain()
{
    // store our process ID for handshake
    ((DWORD*)shared_mem)[REMOTE_PROCESS_ID_WORD] = GetCurrentProcessId();

    // Wait on the Main to set up connection
    DWORD result = WaitForSingleObject(gOverlayWaitingOnConnectionSema, CONNECT_WAIT_MILLIS);

    if(result == WAIT_TIMEOUT) {
        return IPC_CONNECT_TIMEOUT;
    }

    if(result == WAIT_OBJECT_0 + 0) {
        // Get the Main's process ID
        DWORD hostProcessId = ((DWORD*)shared_mem)[HOST_PROCESS_ID_WORD];
        gMainProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, TRUE, hostProcessId);

        // Release the Main to get our process Id and continue
        ReleaseSemaphore(gMainWaitingOnConnectionSema, 1, nullptr);

        // Then wait one more time until we know the Main has our process
        // ID so we don't overwrite it with something else
        DWORD result = WaitForSingleObject(gOverlayWaitingOnConnectionSema, CONNECT_HANDSHAKE_WAIT_MILLIS);

        if(result == WAIT_TIMEOUT) {
            return IPC_CONNECT_TIMEOUT;
        }

        return IPC_CONNECT_SUCCESS;
    }

    return IPC_CONNECT_ERROR;
}

// Call from Main to set up connection from the Overlay
void IPCSetupForOverlayConnection()
{
    DWORD result;

    // clear request and response semaphores
    result = WaitForSingleObject(gMainResponseSema, 0);
    if(result == WAIT_OBJECT_0) {
        OutputDebugStringA("**OVERLAY** Ah, indeed there was a MainResponse sema posted\n");
    } else {
        OutputDebugStringA("**OVERLAY** No MainResponse sema posted\n");
    }
    result = WaitForSingleObject(gOverlayRequestSema, 0);
    if(result == WAIT_OBJECT_0) {
        OutputDebugStringA("**OVERLAY** Ah, indeed there was a OverlayRequest sema posted\n");
    } else {
        OutputDebugStringA("**OVERLAY** No OverlayRequest sema posted\n");
    }

    // store our process ID for handshake
    ((DWORD*)shared_mem)[HOST_PROCESS_ID_WORD] = GetCurrentProcessId();

    // Signal the remote that the host is waiting on a connection
    ReleaseSemaphore(gOverlayWaitingOnConnectionSema, 1, nullptr);
}

// Call from Main to get Overlay Connection or timeout
IPCConnectResult IPCWaitForOverlayConnection()
{
    // Wait on the remote connection
    DWORD result;
    result = WaitForSingleObject(gMainWaitingOnConnectionSema, CONNECT_WAIT_MILLIS);

    if(result == WAIT_TIMEOUT) {
        return IPC_CONNECT_TIMEOUT;
    }

    if(result == WAIT_OBJECT_0) {

        // Get the Overlay's process ID
        DWORD remoteProcessId = ((DWORD*)shared_mem)[REMOTE_PROCESS_ID_WORD];
        gOverlayProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, TRUE, remoteProcessId);

        // Finally, let the Overlay know we have its ID
        ReleaseSemaphore(gOverlayWaitingOnConnectionSema, 1, nullptr);

        return IPC_CONNECT_SUCCESS;
    }

    return IPC_CONNECT_ERROR;
}

// Call from Overlay when request in shmem is complete
void IPCFinishOverlayRequest()
{
    ReleaseSemaphore(gOverlayRequestSema, 1, nullptr);
}

// Call from Main to get complete request in shmem
IPCWaitResult IPCWaitForOverlayRequestOrTermination()
{
    HANDLE handles[2];

    handles[0] = gOverlayRequestSema;
    handles[1] = gOverlayProcessHandle;

    DWORD result;

    do {
        result = WaitForMultipleObjects(2, handles, FALSE, REMOTE_REQUEST_WAIT_MILLIS);
    } while(result == WAIT_TIMEOUT);

    if(result == WAIT_OBJECT_0 + 0) {
        return IPC_REMOTE_REQUEST_READY;
    }

    if(result == WAIT_OBJECT_0 + 1) {
        return IPC_REMOTE_PROCESS_TERMINATED;
    }

    return IPC_WAIT_ERROR;
}

// Call from Main when response in shmem is complete
void IPCFinishMainResponse()
{
    ReleaseSemaphore(gMainResponseSema, 1, nullptr);
}

// Call from Overlay to get complete request in shmem
IPCWaitResult IPCWaitForMainResponse()
{
    DWORD result;

    HANDLE handles[2];

    handles[0] = gMainResponseSema;
    handles[1] = gMainProcessHandle;

    do {
        result = WaitForMultipleObjects(2, handles, FALSE, HOST_RESPONSE_WAIT_MILLIS);
    } while(result == WAIT_TIMEOUT);

    if(result == WAIT_OBJECT_0 + 0) {
        return IPC_HOST_RESPONSE_READY;
    }

    if(result == WAIT_OBJECT_0 + 1) {
        return IPC_HOST_PROCESS_TERMINATED;
    }

    return IPC_WAIT_ERROR;
}

// Set up shared memory using a named file-mapping object. 
bool MapSharedMemory(UINT32 req_memsize)
{ 
    mutex_handle = CreateMutex(NULL, TRUE, kSharedMutexName);
    if (NULL == mutex_handle) return false;
    bool first = (GetLastError() != ERROR_ALREADY_EXISTS); 

    shared_mem_handle = CreateFileMapping( 
        INVALID_HANDLE_VALUE,   // use sys paging file instead of an existing file
        NULL,                   // default security attributes
        PAGE_READWRITE,         // read/write access
        0,                      // size: high 32-bits
        req_memsize,            // size: low 32-bits
        kSharedMemName);        // name of map object

    if (NULL == shared_mem_handle)
    {
        OutputDebugStringA("**OVERLAY** failed to CreateFileMapping\n");
        if (first) ReleaseMutex(mutex_handle); 
        CloseHandle(mutex_handle);
        return false; 
    }

    // Get a pointer to the file-mapped shared memory, read/write
    shared_mem = MapViewOfFile(shared_mem_handle, FILE_MAP_WRITE, 0, 0, 0);
    if (NULL == shared_mem) 
    {
        OutputDebugStringA("**OVERLAY** failed to MapViewOfFile\n");
        if (first) ReleaseMutex(mutex_handle); 
        CloseHandle(mutex_handle);
        return false; 
    }

    MEMORY_BASIC_INFORMATION mbi = { 0 };
    VirtualQueryEx(GetCurrentProcess(), shared_mem, &mbi, sizeof(mbi));
    mem_size = mbi.RegionSize;

    // First will initialize memory
    if (first)
    {
        memset(shared_mem, '\0', mem_size); 
        ReleaseMutex(mutex_handle);
    }
    
    return true;
}

// Unmap the shared memory and release handle
//
bool UnmapSharedMemory()
{
    // Close handle to mutex
    CloseHandle(mutex_handle);

    // Unmap shared memory from the process's address space
    bool err = UnmapViewOfFile(shared_mem); 
 
    // Close the process's handle to the file-mapping object
    if (!err) err = CloseHandle(shared_mem_handle);

    return err;
} 

